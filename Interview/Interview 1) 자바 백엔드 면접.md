
#### 🔸CallbyValue vs. CallByReference

`Call by Value` 는 인자로 받은 값을 복사하여 처리하고 
`Call By Reference` 는 인자로 받은 값의 주소를 참조하여 값에 직접 영향을 줍니다. 

`CallbyValue` 경우는 원본 값을 건드리지 않고  값을 복사하여 사용하여 값의 불변성을 유지하는데 용의 합니다.  
그러나 값을 복사하기 때문에 메모리 사용량이 늘어나게 됩니다. 

`CallbyReference` 의 경우 복사하지 않고 직접 변수의 주소에 저장된 값을 참조하여 변경하기 때문에 빠르지만 원래 값이 영향을 받는다는 단점이 있습니다. 

==Java== 의 경우 오직 `CallByValue` 로 동작합니다. 
그 이유는 Java 는 변수를 선업하면 Stack 영역에 할당되는데 Stack 에는 Primitive Type  만 저장되며 참조타입(Reference Type)은 Heap 에 저장됩니다. 

#### 🔸 Overriding vs. Overloading 

둘다 메소드를 재정의 또는 확장하는 개념입니다. 

`Overriding`은 부모 클래스의 상속 받은 클래스에서 확장하는 개념으로 메소드 이름과 매개변수,  return type 모두 일치 해야합니다. 

`Overloading` 은 하나의 클래스 내부에서 확장하는 개념으로 이름은 일치하지만 매개변수의 개수나 return 타입이 달라져야 합니다. 

#### 🔸 Rest API

Rest 란 자원을 이름으로 구분하여 해당 자원의 상태 (정보)를 주고 받는 것을 의미하며 상태에는 Json 혹은 XML 과 같은 데이터를 주고 받습니다. 

HTTP Method 에는 ==GET, POST, PUT, DELETE== 이 있고 CRUD Operation 적용을 의미합니다. 

Rest 가 필요한 이유는 Server/Client 의 역할 분리 그리고 브라우저와 모바일 디바이스에서의 최적화된 통신 (다양한 클라이언트 등장)이 있습니다. 

Rest API 는 Rest 를 기반으로 서비스 API 를 구현한 것으로 확장성과 재사용성을 높여 유지보수 및 운용을 편하게 할 수 있습니다.
Restful 의 목적은 성능 향상이 아닌 일괄적인 컨벤션을 통한 API 의 이해도 및 호환성을 높이는 것으로 성능이 중요한 상황에서는 굳이 Restful 한 구연을 할 필요는 없습니다. 

#### 🔸 Java 를 사용하는 이유?

Java 는 객체 지향적인 언어로 보안성이 뛰어나며 전자정부 프레임워크로 지정되어서 수요가 높습니다. 
Java 를 특히 더 많이 사용하는 이유는 컴파일된 코드가 플랫폼 독립적이기에 윈도우, 맥, 리눅스에 영향을 받지 않고 실행이 됩니다. 

자바 컴파일러 (JVM)는 자바 바이트 코드를 어느 플랫폼에서나 동일한 형태로 실행시켜주며 운영체제 종류에 상관없이 실행 가능합니다. 

#### 🔸 단방향 Encryption / 양방향 Encryption

단방향 암호화는 암호화만 가능하고 복호화가 불가능합니다. 대표적으로는 Hash 가 있으며 임의의 길이 메세지로부터 고길이의 해시값을 계산합니다. 단방향 암호화는 해시값으로부터 메세지를 역산 할 수 없는 일방향성을 가집니다. 

양방향 암호화는 암호화, 복호화 모두 가능하며 대칭키 방식과 비대칭키 방식이 있습니다. 
대칭키 방식은 암호화, 복호화 시 동일한 키를 사용하는 것이고
비대칭키는 암호화 복호하에서 다른 키를 사용합니다. 

대칭키는 암호화, 복호화에 같은 키를 사용하기 때문에 비공개 키를 가집니다.
그렇기에 속도는 빠르지만 키 전달 과정에서 노출 우려가 있습니다. 

비대칭키는 암복호화에 서로 다른 키가 사용되는 암호화 방식으로 하나의 키는 공개키로 사용하고 나머지 키는 복호화 키로 사용합니다. 이렇게에 키 배송의 문제를 차단하여 안정성이 높다는 장점이 있으나 대칭키 방식에 비해 느립니다. 


#### 🔸 객체지향 이란? 

프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체를 만들고 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다. 

객체지향의 장점은 ==코드 재사용이 용이하며 유지보수가 쉬워== 대형 프로젝트에 적합합니다. 
그러나 처리 속도가 상대적으로 느리고 용량이 커질 수 있습니다. 

#### 🔸 OOP 4대 특성 ?

캡슐화, 상속, 추상화, 다형성이 있습니다. 

`캡슐화`란 기능과 특성을 "클래스"라는 "캡슐"에 분류해서 넣는 것 입니다. 
이는 코드를 재수정 없이 재활용하고 접근 제어자를 통한 정보 은닉을 위한 목적을 가집니다.

`상속 (extends)` 은 부모 클래스의 상속과 기능을 그대로 이어받아 일부분을 변경해야 하는 경우 상속받은 자식클래스에서 해당 기능만 다시 재정의하여 사용할 수 있게 하는 것입니다. 다중상속은 불가합니다. 

`추상화는(abstraction)` 은 클래스를 설계하는 것 자체로 "공통의" 속성이나 기능을 묶어 이름을 붙이는 것입니다. 

`다형성`은 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것으로 오버라이딩, 오버로딩이 가능하다는 의미입니다. 
#### 🔸 SOLID ? 

 `Single Response Principle : 단일 책임 원칙`
모든 클래스는 각각 하나의 책임만 가져야 하며 클래스는 그 책임을 완전히 캡슐화해야  합니다.

`Open Closed Principle : 개방 폐쇄 원칙`
확장에는 열려있고 수정에는 닫혀있는 기존의 코드를 변경하지 않으면서( Closed), 기능을 추가할 수 있도록(Open) 설계가 되어야 한다는 원칙을 말합니다.

`Liskov Substitution Principle : 리스코프 치환 원칙`
자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다는 원칙이며 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 합니다. 자식클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야 LSP를 만족합니다.

 `Interface Segregation Principle : 인터페이스 분리 원칙`
 한 클래스는 자신이 사용하지않는 인터페이스는 구현하지 말아야 합니다. 하나의 일반적인 인터페이스보다 여러개의 구체적인 인터페이스가 낫습니다.

`Dependency Inversion Principle : 의존 역전 원칙`
의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것입니다. 한마디로 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺어야 합니다.

#### 🔸 Spring 과 Spring boot 차이?

스프링은 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션으로  전 영역을 포괄하는 버용적인 프레임워크입니다. 전 계층과 영역에 핵심 기술의 프로그래밍 모델을 적용해 개발을 편리하게 해주며 주요 기술은 IoC, DI, AOP, PSA가 있습니다. 

스프링 부트를 통해 개발자들에게 비즈니스 로직 개발에만 집중할수 있고 환경 설정에 대한 고민을 줄일수 있는 환경을 제공합니다.  Spring MVC 를 사용하며 기본 프로젝트 세팅 시간이 오래 걸려 하기 설정들을 제공합니다. 
 1) Embedded Tomcat 사용
2) starter project 를 제공하며 Autoconfiguration 을 이용하여 모든 내부 디펜던시를 관리하도록 자동화 설정합니다. 
3) spring boot 의 보안을 자동 활성화 시켜줍니다. 
	- pring 에서는 spring-security-web/ spring security-config 종속성을 모두 필요했습니다.
4) web.xml dispatcher-servlet 과 같은 XML 설정을 하지 않아도 됩니다. 
5) jar file 이용한 자바 옵션만으로 손쉽게 배포가 가능합니다. 


#### 🔸 IoC And DI

스프링은 Ioc 컨테이너로 빈을 관리하고 스프링은 DI 를 사용합니다. 
`DI` 란 의존성 관계 주입 기능으로 객체를 직접 생성하는것이 아니라 외부에서 생성한 후 주입시켜주는 방식입니다. 
이로인해 모듈간의 결합도가 낮아지고 유연성이 높아집니다. 

주입 방법으로는 1) 생성자 주입 2) setter 주입 3) 필드 주입이 있습니다. 

`IoC(제어의 역전)`은 제어의 흐름을 바꾼다는 의미로  메소드나 객체의 호출작업을 개발자가 정하는 것이 아닌 외부에서 결정되는 것을 의미합니다.  객체의 의존성을 역전시켜 결합도를 줄이고 유연한 코드를 생성할 수 있게 하여 가독성 및 유지보수가 편리합니다. 스프링이 의존성 객체를 만들어주고 주입시켜줌으로 Bean 들은 싱글턴 패턴의 특징을 가지고 있습니다. 

#### 🔸 Spring Web MVC의 Dispatcher Servlet의 동작 원리

`Dispatcher Servlet` 이란 HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 보내주는 Front Controller 입니다. 

동작 과정으로는 

1. 클라이언트에서 HTTP 요청을 보냅니다.
2. Dispatcher Servlet 이 모든 요청을 가로채갑니다.
3. Handler Mapping 에서 요청된 정보(URI, HTTP Method)와 일치하는, 등록된 핸들러 (컨트롤러 or 정적리소스)가 있는지 찾습니다.
4. 찾은 핸들러(컨트롤러)를 처리할 수 있는 핸들러 어댑터를 조회합니다.
5. 핸들러 어댑터를 통해 핸들러(컨트롤러)를 실행하여 ModelAndView 로 반환합니다.
6. ModelAndView 에 ViewName이 있다면, viewResolver에서 논리 이름으로 변경하여 View를 반환합니다.
	  ex) "hello" -> "/WEB-INF/views/hello.jsp"

6-1. view 를 reander 하여 화면을 호출합니다.

![[Interview 1) 자바 백엔드 면접-1710833211925.jpeg]]

#### 🔸 URL 동작 방법

![[Interview 1) 자바 백엔드 면접-1710833153766.jpeg]]

1, 2) 사용자가 웹 브라우저에서 페이지의 URL 을 입력합니다.
3) 사용자가 입력한 UR 주소 중 도메인 네임을 DNS 서버에서 검색합니다. 
4) DNS 서버 도메인 네임의 IP 를 찾아 사용자가 입력한 URL 정보와 함께 전달합니다.
5, 6) 웹 페이지 URL 정보와 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메세지를 생성합니다. 
7) HTTP 요청 메세지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해다 IP 주소 서버로 전송됩니다. 
8) 도착한 웹 페이지의 URL 정보의 데이터를 검색합니다.
9, 10) 검색된 웹 페이지 데이터를 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메세지를 생성합니다. 그리고 TCP 프로토콜을 사용하여 원래 컴퓨터로 전송 됩니다.
11) 도착한 HTTP 응답 메세지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환됩니다. 
12) 변환된 웹 페이지 데이터는 웹 브라우저에 의해 출력되어 사용자가 볼 수 있습니다.


